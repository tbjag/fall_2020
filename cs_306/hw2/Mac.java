import java.security.Key;
import java.util.Arrays;

// Implement this class
public class Mac extends MacSkeleton {

    /**
     * Implement the mac and verify methods.  Mac should take a message and a
     * key (generated by the generate method) and return a tag.  Verify should
     * take a message, tag, and key -- and authenticate that the tag corresponds
     * to the message/tag pair by returning true or false.
     *
     * The following methods have been made available to you through the
     * MacSkeleton class:
     *
     * byte[] xor(byte[] a, byte[] b) :: XOR two byte arrays. Returns result
     * byte[] pad(byte[] message, int blockSz) :: pads message to blockSz
     * byte[] encryptBlock(byte[] block, Key key) :: Encrypts a single block
     * int getBlockSize() :: Returns the block size of the cipher
     */

    /**
     * Creates a message authentication tag for a message with a given key.
     * @param message   The message to generate a MAC for
     * @param key       A secret key to use for MAC'ing the message
     * @return          A valid tag for the message
     * will use CBC mac since that looks decent
     */
    public byte[] mac(byte[] message, Key key) {
        //pad the msg
        byte[] padded_msg = pad(message, getBlockSize());
        //create result
        byte[] res = new byte[padded_msg.length];
        //create a temp
        byte[] temp = new byte[getBlockSize()];
        //curr
        byte[] prev = new byte[getBlockSize()];

        //CBC doesnt really work on single blocks
        if(padded_msg.length / getBlockSize() == 1){
            try {
				res = encryptBlock(padded_msg, key);
			} catch (Exception e) {
				e.printStackTrace();
			}
        }else{
            //CBC MAC
            //get the message by block
            for (int j = 0; j < getBlockSize(); j++){
                temp[j] = padded_msg[j];
            }
            try {
				prev = encryptBlock(temp, key);
			} catch (Exception e) {
				e.printStackTrace();
			}
            //push by block into result
            for (int j = 0; j < getBlockSize(); j++){
                res[j] = prev[j];
            }

            //chain the rest with its previous
            for (int i = 1; i < (padded_msg.length / getBlockSize()); i++){
                //get the message by block
                for (int j = 0; j < getBlockSize(); j++){
                    temp[j] = padded_msg[j + (i * getBlockSize())];
                }
                try {
					temp = encryptBlock(temp, key);
				} catch (Exception e) {
					e.printStackTrace();
                }
                //CBC chain together
                prev = xor(temp, prev);
                //push by block into result
                for (int j = 0; j < getBlockSize(); j++){
                    res[j + (i * getBlockSize())] = prev[j];
                }
            }
        }
        //return result
        return res;
    }

    /**
     * Authenticates a message/tag pair with a key.  Returns true if the pair
     * is authentic, else false.
     * @param message   message to authenticate
     * @param tag       a MAC tag to authenticate with the message
     * @param key       secret key to authenticate the tag with
     */
    public boolean verify(byte[] message, byte[] tag, Key key) {
        //check mac(message, k) = tag
        message = mac(message, key);
        //check that sizes match
        if(tag.length != message.length){
            return false;
        }
        for(int i = 0; i < message.length; i++){
            if(message[i] != tag[i]){
                return false;
            }
        }
        //if no differences, then return true
        return true;
    }

}

